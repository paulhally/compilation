// CUP specification for a simple expression evaluator (w/ actions)

import java_cup.runtime.*;
import java.lang.Number;

action code{:
	Langage lang=new Langage();
	Fonction fonction=new Fonction();
	Programme prog=new Programme();
:}

parser code {:
	
	
	public void syntax_error(Symbol cur_token){

		report_error("\n Erreur de syntaxe! \n Ligne : "+ cur_token.left + "\n Colonne : " + cur_token.right+"\n\n" ,null);
	}

	public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception{
		report_fatal_error(" Analyse interrompue (erreur de syntaxe)\n ", null);

	}
:}




terminal OR, AND, PPE, PGE, PPS, PGS, EQ, IMP, NON, EQUI;
terminal LPAR, RPAR, PLUS, MINUS, TIMES, DIVIDE, MINUS_U, SEMIC;
terminal MAIN, VIRGULE, IF, ELSE, FOR, WHILE, RACC, LACC;
terminal INT, FLOAT, BOOL, UNSIGNED, STRING, CHAR;
terminal String ID;
terminal Integer NUMBER;
terminal Float FLOTTANT; 
terminal Boolean BOOLEEN;
terminal String CAR;
terminal String CHAINE;

non terminal Type type;
non terminal Langage langage;
non terminal LFonction liste_fonction;
non terminal Programme programme;
non terminal Fonction fonction;
non terminal listefonction_parametre;
non terminal Parametre parametre;
non terminal listefonction_instruction;
non terminal instruction;
non terminal listefonction_declaration;
non terminal liste_declaration;
non terminal liste_instruction;
non terminal Declaration declaration;
non terminal instructionIF;
non terminal instructionFOR;
non terminal  instructionWHILE;
non terminal  instructionAFF;
non terminal  testFOR;
non terminal  testIF;
non terminal  liste_testIF;
non terminal  operande;
non terminal  comparateur;
non terminal comparateurFOR;

precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE,PPS,PPE,PPE,PGS,EQ,IMP,OR,AND,EQUI;
precedence left INT, FLOAT, BOOL, UNSIGNED, STRING, CHAR;

start with langage;


langage ::= liste_fonction:lf programme:p {: RESULT=lang; :}
		|error
		;

liste_fonction ::= fonction:f liste_fonction:lf {: lang.ajouterFonction(f); fonction.clearListe(); :}
		| 
		;
		
fonction ::= type:t ID LPAR listefonction_parametre RPAR LACC listefonction_declaration listefonction_instruction RACC {: RESULT=fonction; :};


listefonction_instruction ::= instruction listefonction_instruction {: System.out.println("hey"); :}
		| 
		;
		
listefonction_declaration ::= declaration:d listefonction_declaration {:  fonction.ajouterDeclaration(d); :}
		| 
		;
		
listefonction_parametre ::= parametre:par VIRGULE listefonction_parametre {: fonction.ajouterParametre(par); :}
		| parametre:par {: fonction.ajouterParametre(par); :}
		;



programme ::= MAIN LACC liste_declaration liste_instruction RACC 
			;

declaration ::= type:t ID:id SEMIC {:  RESULT = new Declaration(t,id); :} ;

parametre ::= type:t ID:i {: RESULT = new Parametre(t,i); :}
			| 
			;

instruction ::= instructionIF
		| instructionFOR
		| instructionAFF {: System.out.println("hey"); :}
		| instructionWHILE
		;
		
instructionIF ::= IF LPAR liste_testIF RPAR LACC liste_instruction RACC
				|IF LPAR liste_testIF RPAR LACC liste_instruction RACC ELSE LACC liste_instruction RACC
				;

instructionFOR ::= FOR LPAR ID EQ NUMBER SEMIC testFOR SEMIC ID PLUS PLUS RPAR LACC liste_instruction RACC;

instructionAFF ::= ID:id EQ NUMBER:v SEMIC{: System.out.println("hey"); fonction.affectation(id,String.valueOf(v)); :}
		| ID:id EQ BOOLEEN:v SEMIC {: System.out.println("hey"); fonction.affectation(id,String.valueOf(v)); :}
		| ID:id EQ CAR:v SEMIC {: System.out.println("hey"); fonction.affectation(id,String.valueOf(v)); :}
		| ID:id EQ FLOTTANT:v SEMIC {: System.out.println("hey"); fonction.affectation(id,String.valueOf(v)); :}
		;
		
instructionWHILE ::= WHILE LPAR liste_testIF RPAR LACC liste_instruction RACC;

liste_testIF ::= liste_testIF operande:o liste_testIF
		| testIF
		; 

operande ::= AND 
		| OR
		;

testIF ::= ID comparateur:c ID
		|ID comparateur:c NUMBER
		|ID EQ EQ CHAINE
		|NON ID
		|ID
		|ID EQ EQ BOOLEEN
		;
		
comparateur ::= PPE| PGE| PPS| PGS| EQ EQ;

comparateurFOR ::= PPE
				| PGE
				| PPS
				| PGS
				;

testFOR ::= ID comparateurFOR ID 
		| ID comparateurFOR NUMBER
		;
		
type ::= INT {: RESULT=new Type(EnumType.INTEGER); :}
		| FLOAT {: RESULT=new Type(EnumType.FLOAT); :}
		| BOOL {: RESULT=new Type(EnumType.BOOLEAN); :}
		| CHAR {: RESULT=new Type(EnumType.CHARACTER); :}
		|UNSIGNED {: RESULT=new Type(EnumType.UNSIGNED); :}
		;